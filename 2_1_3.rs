// 2.1.3　寻址和字节顺序
use std::mem;

/**
 * 定义了一个指向 u8 的常量指针类型别名
 * 补充问题：这里为什么使用 u8 呢
 * 原因：
 * 1、字节单位
 *      1、字节大小：在计算机中，字节通常表示为 8 位。在 Rust 中，u8 正好是 8 位无符号整数，与字节的大小完全匹配
 *      2、内存表示：任何类型的变量（如 i32、f32 等）在内存中都是按字节存储的。通过将这些变量的地址转换为 u8 指针，可以逐字节地访问和显示它们的内存表示
 * 2、类型安全
 *      1、低级内存操作：在进行低级别的内存操作时，使用 u8 可以确保我们正在处理的是单个字节的数据。这在需要逐字节访问内存时非常重要，因为这可以防止意外地读取或写入超过一个字节的数据
 *      2、类型转换：在 Rust 中，u8 是最适合用于表示和操作原始字节数据的类型。其他类型（如 i32、f64 等）可能会引入额外的复杂性和潜在的错误
 * 3、与 C 语言兼容     
 *      1、C 语言惯例：在 C 语言中，字节通常表示为 unsigned char，这是一个 8 位无符号整数。Rust 中的 u8 与 C 的 unsigned char 完全对应，因此在需要与 C 代码交互或移植 C 代码时，使用 u8 是最直接和兼容的选择
 * */
type BytePointer = *const u8;

fn show_bytes(start: BytePointer, len: usize) {
    for i in 0..len {
        // 使用 unsafe 块来解引用指针，这是因为 Rust 的安全机制默认不允许直接解引用裸指针
        unsafe {
            // 使用 u8 逐字节访问内存；start.add(i) 用于计算偏移后的指针位置
            // {:02x} 打印每个字节的十六进制值，每行打印 2 个字节
            print!("{:02x}", *start.add(i));
        }
    }
    println!();
}

fn show_int(x: i32) {
    // 将 i32 类型的地址转换为 u8 指针
    // mem::size_of::<i32>() 返回 i32 类型的字节大小
    // 此处直接 as *const u8 也可以
    show_bytes(&x as *const i32 as BytePointer, mem::size_of::<i32>());
}

fn main() {
    let x: i32 = 12345; // mac m2pro 输出：39 30 00 00 (小端序)
    show_int(x);
}
